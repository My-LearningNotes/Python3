函数
====

将语句组合在一起, 作为一个执行单元, 就是函数.

函数是代码归集的方法之一, 使用函数可以实现代码的重用, 可以提高代码的可读性, 可以使代码有更好的组织结构.


抽象和结构
----------

函数是一种抽象.

抽象可以节省人力, 但实际上还有个重要的优点:
抽象是程序能够被人理解的关键所在(无论对编写程序还是阅读程序来说, 这都至关重要).

使用函数, 可以实现\ **做什么**\ 和\ **怎么做**\ 的分离, 我们在阅读和使用时, 只需要关心函数能做什么, 而不需要关心其是怎么实现的, 从而便于我们的理解和使用.


自定义函数
----------

一般而言, 可以使用内置的\ ``callable``\ 函数, 判断某个对象是否可调用.

自定义函数的基本语法:

.. code-block:: Python3
    :emphasize-lines: 1, 2

    def 函数名(参数列表):
   	    函数体


给函数编写文档
~~~~~~~~~~~~~~

要给函数编写文档, 以确保其他人能够理解, 可添加注释(以\ ``#``\ 打头的内容).

还可以给函数编写\ **文档字符串(docstring)**\ , 文档字符串定义在函数的开头(\ ``def``\ 语句的下一行).

函数的文档字符串作为函数的一部分存储起来, 可以通过\ ``__doc__``\ 属性获取文档字符串.

在交互式解释器中, 可以使用内置的\ ``help``\ 函数, 获取有关函数的信息, 其中包括函数的文档字符串.


函数的返回值
~~~~~~~~~~~~

在C/C++中, 需要显式定义函数的返回值类型; 在Python中, 不需要定义函数的返回值类型.

在Python中, 有些函数什么都不返回.
什么都不返回的函数不包含\ ``return``\ 语句, 或者包含\ ``return``\ 语句但没有在\ ``return``\ 后面指定值.

**在Python中, 所有的函数都有返回值, 如果没有显式指定返回值, 则函数返回\ ``None``\ .**


参数魔法
--------

*   在定义函数时，可以定义参数列表(形参);

*   在调用函数时，向其传递参数(实参);

*   函数调用时，形参绑定到实参对象.


在函数体中修改参数 or not?
~~~~~~~~~~~~~~~~~~~~~~~~~~

**在Python中, 数, 字符串和元组, 属于不可变类型(immutable); 集合, 列表和字典, 属于可变类型(mutable).**

在Python中, 不管实参是不可变类型的还是可变类型的, 在函数调用时, 形参绑定到实参对象.

若实参是不可变类型的, 在函数体中当然不能修改它, 但是需要注意, 在函数体中可以将形参重新绑定到其他的对象.

若实参是可变类型的, 在函数中可以修改它, 但是需要注意执行的操作是\ **对形参的重新绑定**\ 还是\ **对形参绑定的对象的修改**.

在Python中, 一切都是对象.
变量, 只是一个名称, 其绑定到一个对象, 变量和其绑定的对象之间的关系, 类似于map结构.

.. note::

    C/C++属于编译型的语言, 变量和对象之间的绑定, 在编译时就确定的.

    Python数据解释执行的语言, 变量和对象之间的绑定, 在运行时确定的.

**在Python中, 赋值即变量定义, 赋值就是将变量到绑定对象;
之后, 可以将变量再绑定到别的对象（这是对变量的操作, 变量的重新绑定)**

**对于可变类型, 如果是对变量绑定的对象的修改操作, 会影响到所有绑定该对象的变量(对变量绑定的对象的修改).**

在Python中, 变量之间的赋值, 是将变量绑定到同一个对象, 而不是重新分配对象.

Example:

.. code-block:: python

    a = [1, 2, 3]
    b = a # b和a绑定到同一个对象
    b = [4, 5, 6] # 变量b重新绑定，这是对变量的操作
    c = a # c和a绑定到同一个对象
    c[0] = 100 # 对变量绑定的对象操作，会影响所有绑定到该对象的变量

所以, 这里要注意区分的概念是: **是对变量的绑定，还是对变量绑定的对象的修改.**

.. note::

    对变量, 可以重新绑定;
    对变量绑定的对象的操作, 会影响到所有绑定到该对象的变量.

对于可变类型的数据, 在函数调用参数传递时或变量赋值时, 为了避免对变量绑定的对象的修改影响到其它变量, 可以创建对象的\ **副本**\ , 让变量绑定到该副本.

对于序列执行切片操作时, 返回的切片都是副本.
因此, 如果创建覆盖这个列表的切片, 得到的将是列表的副本.

Example:

.. code-block:: python

    names = ['hello', 'world']
    n = names[:] # 创建一个对象的副本，并将n绑定到该副本
    # 这样,n和names是相等的，但它们绑定的是不同的对象

.. note::

    还可以使用``copy``\ 模块中的\ ``deepcopy``\ .


位置参数，关键字参数和参数的默认值
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*   位置参数

参数的位置至关重要, 函数调用时, \ **根据位置顺序来传递参数**\ .

*   关键字参数

参数的位置无关重要, 函数调用时, \ **根据名称(关键字)来传递参数**\ .

*   参数的默认值

对于函数的参数, 我们可以为其定义默认值. 当函数调用时, 如果没有提供参数值, 则使用默认值.

可以只为部分参数定义默认值, 这样的话, 应该将所有没有指定默认值的参数写在前面, 将所有指定了默认值的参数写在后面.

还可以结合使用位置参数和关键字参数, 但必须先指定所有的位置参数(即把所有的位置参数写在前面).

**通常, 不应该结合使用位置参数和关键字参数, 因为这容易引起混乱.**


收集多余的参数
~~~~~~~~~~~~~~

有时候, 在调用函数时, 允许用户提供任意数量的参数很有用.

函数定义时, 参数列表中以\ ``*``\ 开头的参数, 表示一个元组, 用来收集\ **多余的位置参数**\ .

根据在参数列表中定义的位置, \ ``*param1``\ 收集实参中从其定义的位置开始到结束的所有位置参数.
如果没有多余的位置参数, 则该元组是一个空元组.

以两个星号\ ``**``\ 开头的参数, 表示一个map, 用来收集\ **多余的关键字参数**\ .

一个星号不会收集关键字参数, 要收集关键字参数, 可使用两个星号.

``**param2``\ 只能定义在参数列表的结尾, 表示收集实参中多余的关键字参数.
如果没有多余的关键字参数, 则该map是一个空的map.

通常, 可以结合使用\ ``*param1``\ 和\ ``**param2``\ , 将它们定义在参数列表的末尾位置，收集必需参数之外的位置参数和关键字参数.

Example:

.. code-block:: python

    def print_params(x, y, z=3, *pospar, **keypar):
        print(x, y, z)
        print(pospar)
        print(keypar)


分配参数
~~~~~~~~

收集参数, 是\ **函数定义时**\ 在参数列表中定义, 在函数体中实现, 将多余的参数收集在元组或map中.

与之相反的, 分配参数, 是在\ **函数调用时**\ , 将数据结构中的元素拆解, 作为参数传递给函数.

``*param1``\ , 函数调用时，将一个\ **元组/列表/字符串**\ 中的元素解包(依次取出各个元素), 作为位置参数传递给函数.

``**param2``\ , 函数调用时, 将一个\ **字典**\ 解包, 作为关键字参数传递给函数.


作用域
------

*   **在Python中, 一切都是对象; 变量就是一个名称, 绑定到对象.**

当执行赋值语句\ ``x = 1``\ 之后, 名称\ ``x``\ 就绑定了值1, 这几乎与使用字典时一样(字典中的键指向值).

.. note::

    变量和其绑定的对象之间, 就是一种map结构, 存储在**参数对照表**\ 中.

*   **作用域，字面意思是指名称的有效范围**

变量和其绑定的对象, 记录在\ **参数对照表(符号表)**\ 中, 在变量绑定时, 根据参数对照表确定绑定关系(即确定绑定的是哪一个对象).

**Python是使用静态作用域的语言**\ , 每个作用域都有自己的参数对照表, 在各个作用域中使用各自的参数对照表.

在程序中的不同位置定义的变量, 有着不同的作用域, 变量的绑定关系记录在不同的参数对照表中.

*   变量的作用域, 就是指变量的绑定关系记录在哪个参数对照表中;

*   Python中的作用域一共有4种:

    -   ``B``\ (Built-in)内建作用域

    在整个程序范围内有效

    - ``G``\ (Global)全局作用域

    在文件范围内有效

    - ``E``\ (Enclosing)闭包作用域

    在闭包范围内有效

    - ``L``\ (Local) 局部作用域

    在函数内部有效

*   在不同的作用域中, 可以使用相同的名称, 因为它们记录在不同的参数对照表中, 所以不会相互干扰

**变量绑定时, 按照作用域的由内向外查找绑定关系, 以第一个查找到的绑定关系为准.** 


作用域和数据遮盖的问题
~~~~~~~~~~~~~~~~~~~~~~

当前作用域中的变量, 会覆盖外部作用域中的同名变量. 
如果要访问外部作用域中的同名变量, 需要\ **显式定义**\ .

如果要显式访问全局作用域的变量, 可以使用\ ``globals``\ 函数, 它会返回一个包含全局变量的字典: \ ``globals()['parameter']``


重新关联全局变量/外部变量
~~~~~~~~~~~~~~~~~~~~~~~~~

因为\ **Python赋值即变量定义**\ 的特性, 如果在当前作用域对变量执行赋值操作:

    *   **如果当前作用域中有该变量，赋值操作表示重新绑定该变量**
    *   **如果当前作用作用域中没有该变量，赋值操作表示在当前作用域中定义该变量并绑定**

这个特性决定了在当前作用域中无法通过简单赋值操作重新绑定外部作用域中的变量, 需要做一些额外的工作:

    *   如要需要在当前作用域中重新绑定全局变量, 则需要先使用\ ``global``\ 关键字声明该变量, 再执行赋值操作, 这样就表示重新关联全局作用域的变量;
    *   如果需要在当前作用域中重新绑定外部作用域中变量(非全局作用域, 或者说闭包作用域中), 则需要先使用\ ``nonlocal``\ 关键字声明该变量, 再执行赋值操作.

引入新的作用域
~~~~~~~~~~~~~~

在Python中:

    *   包，模块，类会引入新的作用域;

    *   代码块（如\ ``if/elif/else``\ , \ ``try/except``\ , \ ``for/while``\ , ``with ... as ...``\ 不会引入新的作用域的, 
        也就是说这些代码块中定义的变量, 其作用域是该代码块所在的作用域, 在代码块外部也可以访问代码块中的定义的变量.

.. warning::

    在C/C++中, 代码块会引入新的作用域.

Example:

.. code-block:: python

    if True:
        msg = "This is True"
    else:
        msg = "This is False"

    print(msg)

    def test():
        msg = "This is a test"

    test()
    print(msg)


嵌套作用域和闭包
~~~~~~~~~~~~~~~~

在Python中, 允许函数的嵌套定义, 即在一个函数的内部定义另一个函数.

* 嵌套定义的函数, 可以在定义之后就调用:

.. code-block:: python

    def foo():
        def bar():
            print('Hello, world.')
        bar()

    foo()


* 可以使用嵌套函数来创建并返回另一个函数:

.. code-block:: python

    def multiplier(factor):
        def multiplyByFactor(number):
            return factor * number
        return multiplyByFactor # 定义函数之后并没有调用，而是将其作为返回值

像这样, 一个函数位于另一个函数中, 且外面的函数返回里面的函数; 也就是返回一个函数, 而不是调用它.
重要的是, 返回的函数能够访问其定义所在的作用域. 换而言之, 它携带着自己所在的环境（和相关的局部变量), 这就是\ **闭包**\ .

Example:

.. code-block:: python

    def foo(x):
        def bar(y):
            return x*y
        return bar

f1 = foo(10)
print(f1(20))


匿名函数
--------

**匿名函数**\ , 是指没有名字的函数; 与之相对应的是\ **命名函数**\ , 即我们通常使用的函数.

在Python中, 使用关键字\ ``lambda``\ 定义匿名函数, 语法为:

.. code-block:: python

    lambda [args]: expression

Python对匿名函数的支持有限, 只能在一些简单的情况下使用匿名函数.
匿名函数只能有一个表达式, 不需要使用\ ``return``\ 关键字, 表达式的值就是函数的返回值.

什么时候使用匿名函数?

*   当我们将函数作为参数传递时, 有些时候, 直接传入匿名函数比显式定义函数更方便;
*   使用匿名函数, 因为函数没有名称, 不必担心函数名冲突.

.. note::

    *   **匿名函数是一个函数对象**, 可以把匿名函数赋值给一个变量, 再使用该变量来调用该函数;
    *   可以把匿名函数作为函数的返回值.


递归
----

递归是指在一个函数中调用该函数自身.

有用的递归函数通常包含下面两部分:

    *   **基线条件**\ (针对最小的问题): 满足这种条件时函数将直接返回一个值

    *   **递归条件**: 包含一个多个调用, 这些调用旨在解决\ **问题的一部分**

这里的关键是, 通过将问题分解为较小的部分, 可避免递归没完没了, 因为问题终将被分解为基线条件可以解决的最小问题.

可以将函数理解为实现某一个功能的模块, 对函数的调用就是调用功能模块实现某一个功能, 而不管这个函数是其自身还是其他函数.

当可以将问题分解为规模较小的同类问题时, 就适合用递归来解决.


函数式编程
----------

面向函数, \ **可以将函数赋值给变量, 将其作为参数进行传递, 以及从函数返回它们**\ , 像这样使用函数来编写程序, 称为函数式编程.

在Python中, 不会如此倚重函数, 虽然完全可以这么做.
Python是一种面向对象的语言, 我们应该以面向对象的范式来编写Python程序.

