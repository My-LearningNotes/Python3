类和对象
========

Python是一种面向对象的语言, 创建自定义对象是一个Python核心概念.


对象魔法
--------

在面向对象编程中, 术语\ **对象**\ 大致意味着一系列数据(属性)以及一套访问和操作这些数据的方法: **对象 = 属性 + 方法**

面向对象的三大特性:

    *   **封装**
    *   **继承**
    *   **多态**


多态
~~~~

术语\ **多态(polymorphism)**\ , 字面意思是指一个事物\ *有多种形态*\ .

在面向对象程序设计中, 可以这么理解多态: 不同的对象拥有相同的方法, 对不同的对象调用同一个方法, 不同的对象有不同的响应.

-  对同一个方法, 不同的对象都有响应;
-  这大致意味着即便你不知道变量绑定的是哪个对象, 也能够对其执行操作, 且操作的行为将随对象所属的类型而异.

.. note::

    一个方法有多种形态.


封装
~~~~

**封装(encapsulation)**\ 指的是向外隐藏不必要的细节. 
这听起来有点像多态, 这两个概念很像, 因为它们都是\ **抽象的原则**\ , 但封装不同于多态.

-   **多态让你无需知道对象所属的类(对象的类型)就能调用其方法**

-   **封装让你无需知道对象的构造(内部实现细节)就能使用它**

面向对象是以数据为核心的, 将数据和对数据的操作, 封装在类中.


继承
~~~~

继承, 是根据已有的类创建新的类, 实现代码重用.


类
--


类到底是什么
~~~~~~~~~~~~

类是对象的类型, 对象是类的实例.


创建自定义类
~~~~~~~~~~~~


旧式类和新式类
^^^^^^^^^^^^^^

旧式类和新式类是有差别的, 现在实在没有必要使用旧式类了.

-   Python3中没有旧式类了, 创建的类默认就是新式类;

-   在Python3之前, 默认创建的是旧式类;

-   在Python3之前的版本中, 要创建新式类有两种方法:

    *   在脚本或模块开头放置赋值语句: ``__metaclass__ = type``

    *   自定义的类直接或间接继承新式类: ``object``


在Python3中定义类
~~~~~~~~~~~~~~~~~

.. code-block:: python

    class ClassName:
        ...


在Python之前的版本中定义新式类
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: python

    __metaclass__ = type

    class ClassName:
        ...

或

.. code-block:: python

    class ClassName(object):
        ...


属性, 函数和方法
~~~~~~~~~~~~~~~~

**属性**: 在方法中以\ ``self.``\ 开头定义的变量, 属性是每个对象各自独有的.

**方法和函数的区别在于**: 方法的第一个参数为\ ``self``\ , 用来绑定到它所属的实例.
我们调用对象的方法时, 会自动的将\ ``self``\ 绑定到对象, 因此无需提供这个参数.

在Python中, 一切都是对象, 变量可以绑定任何对象.

-   可以将属性绑定到一个普通函数, 但这样就没有特殊的\ ``self``\ 参数了;

-   可以将一个普通变量，绑定到对象的方法;

-   **在Python中, 我们可以在运行时动态地增减对象的属性, 重新绑定属性.**

.. code-block:: python

    #! /usr/bin/env python3

    class Class:
        def method(self):
            print('I have a self ...')

        def another_method(self):
            print('another method')

    def function():
        print('I do not have self ...')

    instance = Class()
    instance.method()
    instance.method = function  # 重新绑定method
    instance.method()

    f1 = instance.another_method
    f1()


再谈隐藏
~~~~~~~~

默认情况下, 可以从外部直接访问对象的属性.
有些程序员认为这没问题, 但有些程序员认为这违反了封装原则, 
他们认为应该对外部完全隐藏对象的状态(即不能在外部直接访问它们).

.. note::

    Python的风格是直接对属性进行读写, 而不通过存取器方法;
    C++中的风格则是使用存取器来访问属性.

可以将属性定义为\ **私有的**\ , 私有属性不能从对象外部直接访问, 而只能通过\ **存取器**\ 方法来访问.
Python没有为私有属性提供直接的支持, 而是要求程序员知道在什么情况下从外部修改属性是安全的.
毕竟, 你必须在知道如何使用对象之后才能使用它.

.. note::

    C++中的私有属性, 提供了一种机制, 用来保证对数据的访问安全;
    在Python中没有提供这种机制, 依靠程序员自己来保证对数据的安全访问.

**在Python中, 要让方法或属性成为私有的(不能从外部访问), 只需让其名称以两个下划线打头即可.**

在Python中, 在类中让名称以两个下划线开头, 并不是真正的让其成为了私有的. 
其幕后的处理方法是: 在类的定义中, 对所有以两个下划线开头的名称都进行转换, 即在开头加上一个下划线和类名. 
这样, 就不能通过原来的名称来访问了, 从而实现了私有的效果. 
但只要知道这种幕后处理手法, 就能从类外访问私有方法, 然而不应该这样做. 
总之, 你无法禁止别人访问对象的私有方法和属性, 但这种名称修改方式发出了强烈的信号, 让他们不要这么做.

如果不希望名称被修改, 又想发出不要从外部修改属性或方法的信号, 可以用一个下划线打头. 这虽然只是一种约定, 但也有一些作用.
例如, \ ``from module import *``\ 不会导入以一个下划线打头的名称.


类作用域
~~~~~~~~

类会引入新的作用域(或者说命名空间): **类作用域**

-   在类中, 在所有方法的外部定义的是\ **类变量**

    *   类变量是属于该类的, 并由该类的所有实例共享
    *   在类中以\ ``类名.类变量``\ 形式访问类变量

-   在类方法中

    *   没有加任何前缀，直接定义的是\ **方法的局部变量**
    *   以\ ``self.``\ 前缀定义的，是\ **属性**
    *   以\ ``类名.变量名``\ 形式定义的，是类变量
    *   以\ ``self.变量名``\ 的形式读变量时，如果没有定义该属性，则查找类变量

访问对象的属性时:

-   **读**\ 对象的数据成员时, 优先查找对象的属性, 如果没有查找到, 则再去查找类变量
-   对对象属性的赋值操作, 如果对象定义了该属性, 表示重新绑定, 否则表示为该对象定义该属性

显式访问类变量时:

-   对类变量的赋值操作, 如果已定义了该类变量, 表示重新绑定, 否则表示定义该类变量

**因为Python赋值即变量定义的特性, 需要注意赋值操作是重新绑定变量还是在当前作用域中定义变量.**

.. note::

    Python赋值即变量定义的特性, 对一个变量进行赋值操作, 如果已经定义了该变量, 表示重新绑定; 如果没有定义该变量, 表示定义之.

Python中的几个作用域:

    *   内置作用域: 在整个程序范围内有效
    *   全局作用域: 在文件范围内有效
    *   闭包作用域
    *   局部作用域: 在函数中有效
    *   类作用域: 属于该类的，由该类的所有实例共享

有的代码是声明, 比如函数/类的定义; 有的代码是执行语句.
但不论是声明, 还是执行语句, 在执行或导入时, Python解释器都会按从上到下的顺序依次执行这些语句.
所以在类的定义中, 并非只能包含\ ``def``\ 语句, 还可以包含其他的语句, 在执行或导入时, 这些语句也会执行.

.. code-block:: python

    class C:
        print('Class C being defined...')

在导入这个类的定义时, 就会执行类定义中的\ ``print``\ 语句.


指定超类(继承)
~~~~~~~~~~~~~~

要指定超类, 可在class语句中的类名后面加上超类名, 并将其用圆括号括起来.

.. code-block:: python
    :emphasize-lines: 2

    # 继承
    class DerivedClassName(BaseClassName):
        ...

-   子类继承超类的所有属性和方法
-   可在子类中重写从超类继承的方法 

    重写的方式为: 在子类中重新定义.

    .. attention::
        Python中不支持函数的重载, 所以一个函数名只能定义一个函数.


深入探讨继承
~~~~~~~~~~~~

-   要确定一个类是否是另一个类的子类, 可以使用内置函数: ``issubclass``
-   如果有一个类, 想知道它的基类, 可访问其特殊属性: ``__bases__``
-   要确定一个对象是否是一个类的实例, 可以使用内置函数: ``isinstance``

使用isinstance通常不是良好的做法, 依赖多态在任何情况下都是更好的选择. 
一个重要的例外情况是使用抽象基类和模块abc时.


多个超类(多重继承)
~~~~~~~~~~~~~~~~~~

Python支持多重继承, 一个子类可以从多个超类继承.

.. note::
    多重继承是一个功能强大的工具.
    然而, 除非万不得已, 否则应避免使用多重继承, 因为在有些情况下, 它可能带来意外的并发症.

使用多重继承时, 有一点务必注意: 
如果多个超类以不同的方式实现了同一个方法(即有多个同名方法), 必须在class语句中小心排列这些超类, 因为位于前面的类中的方法将覆盖位于后面的类的同名方法.

Python中的方法查找算法(C3线性化算法)可以确保:

    -   超类不比子类先查找;
    -   如果有多个超类, 则先查找定义在前面的超类.

.. code-block:: python

    # 多重继承
    class DerivedClassName(Base1, Base2, Base3 ...):
        ...


接口和内省
~~~~~~~~~~

**接口(interface), 可以理解为实现的类型, 是对外暴露的方法或属性.**

Python使用的是\ **鸭子类型**\ .
Python中的多态, \ **关心的是对象的行为，而不是其类型**\ .

.. note::
    在Python中, 不显式指定对象必须包含哪些方法才能用作参数(或必须继承哪个基类).
    例如, 你不会像Java中那样显式编写接口, 而是假定对象能够完成你要求它完成的任务. 
    如果不能完成, 程序将失败.

通常, 要求对象遵循特定的接口(即实现特定的方法), 但如果需要, 也可非常灵活地提出要求: 
不是直接调用方法并期待一切顺利, 而是检查所需的方法是否存在; 如果不存在, 就改弦易辙.


抽象基类
~~~~~~~~

在历史上的大部分时间内, Python几乎都只依赖于\ **鸭子类型**\ , 即假设所有对象都能完成其工作, 同时偶尔使用\ ``hasattr``\ 来检查所需的方法是否存在.
很多其他语言(如Java和Go)都采用\ **显式指定接口**\ 的理念, 而有些第三方模块提供了这种理念的各种实现.
最终, Python通过引入模块\ ``abc``\ 提供了官方解决方案. 
**这个模块为所谓的抽象基类提供了支持**\ .

.. note::
    一般而言, 抽象类是不能(至少是不应该)实例化的类, 其职责是定义子类应实现的一组抽象方法.


Example:

.. code-block:: python

    from abc import ABC, abstractmethod

    class Talker(ABC):

        @abstractmethod
        def talk(self):
            pass

在Python中, 使用\ ``abc``\ 模块定义抽象基类的方法:

-   定义的抽象基类继承\ ``abc.ABC``
-   使用装饰器\ ``@abc.abstractmethod``\ 装饰抽象方法

在Python中, 通过使用抽象基类来实现多态时, 我们可以使用\ ``isinstance``\ 方法来判断某个类是否是抽象基类的子类, 从而判断某个类是否实现了特定的方法.

但有时会有这样的问题:
某个类不是抽象基类的子类, 但是却实现了抽象基类中定义的方法, 按照鸭子类型的精神(关心行为, 而不是类型)该类应该可以用来实现多态, 但是该类却通不过\ ``isinstance``\ 的检查.
为了解决这个问题, 可以将这个类注册为抽象基类的的类型, 这样该类就能通过\ ``isinstance``\ 的检查了.
但是, 这种做法存在一个缺点, 就是直接从抽象类派生提供的保障没有了.

Example:

.. code-block:: python

    from abc import ABC, abstractmethod

    class Talker(ABC):      # 定义抽象基类
        @abstractmethod
        def talk(self):
            pass

    class Kingget(Talker):  # 从抽象基类继承
        def talk(self):     # 重写抽象方法
            print('Ni!')

    class Herring:
        def talk(self):     # 没有从抽象基类继承, 但是却实现了抽象基类中定义的方法
            print('Blub.')

    if __name__ == '__main__':
        k = Kingget()
        if isinstance(k, Talker):  # 判断是否是抽象基类的实例
            k.talk()

        h = Herring()
        Talker.register(Herring)   # 将实现抽象基类中定义的方法的类，注册为抽象基类类型，使其可以通过isinstance检查
        if isinstance(h, Talker):
            h.talk()


--------------


关于面向对象设计的一些思考
--------------------------

-   **将相关的东西放在一起**
  
    如果一个函数操作一个全局变量, 最好将它们作为一个类的属性和方法.

-   **不要让对象之间过于亲密**
  
    方法应只关心其所属实例的属性, 对于其他实例的状态, 让它们自己去管理就好了.

-   **慎用继承, 尤其是多重继承**
  
    继承有时很有用, 但在有些情况下可能带来不必要的复杂性. 
    要正确地使用多重继承很难, 要排除其中的bug更难.

-   **保持简单**
  
    让方法短小紧凑. 
    一般而言, 应确保大多数方法都能在30秒内读完并理解. 
    对于其余的方法, 尽可能将其篇幅控制在一页或一屏内.


确定需要哪些类以及这些类应包含哪些方法时, 尝试像下面这样做:

-   将有关问题的描述(程序需要做什么)记录下来, 并给所有的\ **名词**\ , \ **动词**\ 和\ **形容词**\ 加上标记;
-   在名词中找出可能的类;
-   在动词中找出可能的方法;
-   在形容词中找出可能的属性;
-   将找出的方法和属性分配给各个类.

有了面向对象模型的草图之后, 还需要考虑类和对象之间的关系(如继承或协作)以及它们的职责. 
为进一步改进模型, 可像下面这样做:

-   记录(或设想)一些用例, 即使用程序的场景, 并尽力确保这些用例涵盖了所有的功能;
-   透彻而仔细地考虑每个场景, 确保模型包含了所需的一切. 
    如果有遗漏, 就加上; 如果有不太对的地方, 就修改. 
    不断重复这个过程, 直到对模型满意为止.

有了你认为行之有效的模型后, 就可以着手编写程序了. 
你很可能需要修改模型或程序的某些部分, 所幸这在Python中很容易, 请不用担心.
只管按这里说的去做就好.

