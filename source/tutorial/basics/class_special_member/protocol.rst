Python协议和鸭子类型
====================


什么是协议?
-----------

**协议是非正式的接口, 是让Python这种动态类型语言实现多态的方式.**

在C++中可以通过定义抽象基类, 在Java/Go中可以通过使用关键字\ ``interface``\ , 在语言层面强制实现接口. 
**而在Python中, 协议是非正式的接口, 是一组方法, 但只是一种文档, 语言层面不强制实现.**

**虽然协议是非正式的, 在Python中, 应该把协议当成正式的接口.**

Python中存在多种协议, 用于实现\ **鸭子类型(对象的类型无关紧要, 只要实现了特定的协议 --- 一组方法, 即可)**\ .

**需要称为相对应的鸭子类型, 那就实现相关的协议.** 例如, 实现序列协议(``__len__``\ 和\ ``__getitem__``), 这个类就表现的像序列.

协议是非正式的, 没有强制力, 可以根据具体场景实现一个具体协议的一部分. 例如, 为了支持迭代, 只需要实现\ ``__getitem__``\ , 不需要实现\ ``__len__``\ .

在Python文档中, 如果看到"文件类对象"(表现得像文件的对象), 通常说的就是协议, 这个对象就是鸭子类型. 
这是一种简短的说法, 意思是: "行为基本与文件一致, 实现了部分文件接口, 满足上下文需求的东西."


鸭子类型(Duck Typing)
---------------------

When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck. - James Whitcomb Riley

只要走起来像鸭子, 游起来像鸭子, 加起来像鸭子, 那它就是鸭子(它的行为是鸭子的行为, 那么可以认为它就是鸭子.)

**鸭子类型不关注对象的类型, 而关注对象的行为(方法).** 
只要一个对象实现了相应的方法, 那么它就是鸭子类型, 就是多态的一种形式.


.. note::

    协议, 定义了非正式的接口. 
    一个对象, 只要它实现了相应的协议, 那它就是相应的鸭子类型, 就是相应的多态的一种形式. 
    所以说, 协议是让Python实现多态的方式.

