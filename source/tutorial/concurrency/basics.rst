线程和Python
============

全局解释器锁
------------

Python代码的执行是由Python虚拟机(又名解释器主循环)进行控制的. 
Python在设计时是这样考虑的, 在主循环中同时只能有一个控制线程在执行, 就像单核CPU系统中的多进程一样. 
内存中可以有许多程序, 但是在任意给定时刻只能有一个程序在运行. 
同理, 尽管Python解释器中可以多个线程, 但是在任意给定时刻只有一个线程会被解释器执行.

对Python虚拟机的访问是由\ **全局解释器锁(GIL)**\ 控制的. 
这个锁就是用来保证同时只能有一个线程运行的. 
在多线程环境中, Python虚拟机将按照下面所述的方式执行:

    * 设置GIL;
    * 切换到一个线程去运行;
    * 执行下面操作之一:
        
        * 指定数量的字节码指令;
        * 线程主动让出控制权(可以调用\ ``time.sleep(0)``\ 来完成);
    * 把线程设置回睡眠状态(切换出线程);
    * 解锁GIL;
    * 重复上述步骤.

当调用外部代码时(即, 任意C/C++扩展的内置函数)时, GIL会保持锁定, 直至函数执行结束(因为在这期间没有Python字节码计数). 
编写扩展函数的程序员有能力解锁GIL, 然而, 作为Python开发者, 你并不需要担心Python代码会在这些情况下被锁住.

例如, 对于任意面向I/O的Python例程(调用了内置的操作系统C代码的那种), GIL会在I/O调用前被释放, 以允许其它线程在I/O执行的时候运行. 
而对于那些没有太多I/O操作的代码而言, 更倾向于在该线程整个时间片内始终占有处理器(和GIL). 
换而言之, I/O密集型的Python程序要比计算密集型的代码能够更好地利用多线程环境.


退出线程
--------

当一个线程完成函数的执行时, 它就会退出. 
另外, 还可以通过调用诸如\ ``thread.exit()``\ 之类的退出函数, 或者\ ``sys.exit()``\ 之类的退出Python进程的标准方法, 亦或者抛出\ ``SystemExit`` 异常, 来使线程退出. 
不过, 你不能直接"终止"一个线程. 

.. note::

    对于一个线程, 可以去通知它, 让它自己退出, 但不能从外部直接终止它.

主线程应该做一个好的管理者, 负责了解每个单独的线程需要执行什么, 每个派生的线程需要哪些数据或参数, 这些线程执行完成后会提供什么结果. 
这样, 主线程就可以收集每个线程的结果, 然后汇总成一个有意义的最终结果.


在Python中使用线程
------------------

Python虽然支持多线程编程, 但是还需要取决于它所运行的操作系统. 
如下操作系统是支持多线程的: 绝大多数类Unix平台, 以及Windows平台. 
Python使用兼容POSIX的线程, 也就是众所周知的pthread.


Python的\ ``threading``\ 模块
-----------------------------

Python提供了多个模块来支持多线程编程, 包括\ ``thread``\ , ``threading``\ 和\ ``Queue``\ 模块等. 
程序中可以使用\ ``thread``\ 和\ ``threading``\ 模块来创建和管理线程. 
``thread``\ 模块提供了基本的线程和锁定支持; 而\ ``threading``\ 模块提供了更高级别的, 功能更全面的线程管理. 
使用\ ``Queue``\ 模块, 用于可以创建一个队列数据结构, 用于在多线程之间进行共享. 

.. note::

    推荐使用更高级别的\ ``threading``\ 模块, 而不使用\ ``thread``\ 模块有很多原因. 
    ``threading``\ 模块更加先进, 有更好的线程支持, 并且\ ``thread``\ 中的一些属性会和\ ``threading``\ 模块有冲突. 
    另一个原因是低级别的\ ``thread``\ 模块拥有的同步原语很少(实际上只有一个), 而\ ``threading``\ 模块则有很多. 

    避免使用\ ``thread``\ 模块的另一个原因是它对于进程何时退出没有控制. 
    当主线程结束时, 所有其它线程也都强制结束, 不会发出警告或者进行适当的清理. 
    而\ ``threading``\ 模块至少能确保重要的子线程在进程退出前结束.

